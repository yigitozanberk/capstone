---
title: "Notes"
author: "Yigit Ozan Berk"
date: "10/22/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Course Title

Data Science Specialization SwiftKey Capstone

Course Instructor(s)

Jeff Leek
Roger Peng
Brian Caffo
You are a data scientist now

The goal of this data science specialization has been to give you the basic skills involved with being a data scientist. The goal of this capstone is to mimic the experience of being a data scientist. As a practicing data scientist it is entirely common to get a messy data set, a vague question, and very little instruction on exactly how to analyze the data. Our goal is to give you that same experience but with added support in the form of forums, discussion with instructors, feedback from SwiftKey and Coursera engineers, and a structured problem to solve. We hope that you will take advantage of the opportunity this project affords for you to demonstrate your skills and creativity.

Course Tasks

This course will be separated into 8 different tasks that cover the range of activities encountered by a practicing data scientist. They mirror many of the skills you have developed in the data science specialization. The tasks are:

Understanding the problem
Data acquisition and cleaning
Exploratory analysis
Statistical modeling
Predictive modeling
Creative exploration
Creating a data product
Creating a short slide deck pitching your product
You will hear about each of these tasks over the course of the capstone.

Assessements and Grading

To successfully complete the capstone project, you must receive a passing grade on all of the following assignments:

Quiz 1: Getting Started
Milestone Report: exploratory analysis of the data set + evaluation of at least three classmate submissions
Quiz 2: Natural Language Processing I
Quiz 3: Natural Language Processing II
Final Project: your data product and a presentation describing your final data product + evaluation of at least three classmate submissions
The quizzes will be standard multiple choice quizzes. The other components are graded by peer evaluation.

Your final grade will be calculated as follows

Quiz 1 - 5%
Milestone Report - 20%
Quiz 2 - 10%
Quiz 3 -10%
Final Project -55%
Course dataset

This is the training data to get you started that will be the basis for most of the capstone. You must download the data from the link below and not from external websites to start.

https://d396qusza40orc.cloudfront.net/dsscapstone/dataset/Coursera-SwiftKey.zip
Later in the course you may use external data sets to augment your model as you see fit.

## Regular exp notes

whitespace word boundaries

sets of literals

beginnig and end of a line

alternatives (word1 or word2)

- Start of a line
"^i think"

- end of the line
"morning$"

- sets of characters
"[Bb][Uu][Ss][Hh]"
all case alternatives for the word in e.g. BUSH, BuSH, Bush, bush, bUSH

- all letters from a to z (uppercase or lower case)or numbers from 0 to 9, in the beginning of a line
"^[0-9][a-zA-Z]"

- when you use ^ at the beginning of a character class, it is a metacharacter indicating logical NOT operator.
"[^?.]$"  means = any lines NOT ending with a question mark or a period.

- "any" metacharacter
"9.11" means= 9 followed by any character followed by 11

- "or" metacharacter
"flood|fire|coldfire" will match flood or fire or coldfire

- you can combine
"^[Gg]ood|[Bb]ad" will match Good/good in the beginning of a line or Bad/bad anywhere

"^([Gg]ood|[Bb]ad)" will match Good/good or Bad/bad in the beginning of a line

- "optional" metacharacter
"[Gg]eorge( [Ww]\.)? [Bb]ush" will match where whitespace + [Ww] + . is optional

- backslash escapes metacharacter so . means any character, \. means period 

- repetitions
"*" means repeat any number of times, including none
"+" means at least one

"(.*)" will match any character of any number

"[0-9]+ (.*)[0-9]+" will match, at least one number, followed by whitespace and any number of characters and at least one number again.

- you can quantify the number of repetitions (min and max) you want with the curly brackets{}

"[Bb]ush( +[^ ]+ +){1,5} debate" will match at least one space, followed by something that's not a space, followed by at least one space, and we want to see that between one and five times = we want to see something like space word space.

{m,n} means at least m but not more than n matches
{m} means exactly m matches
{m,} means at least m matches

- in most implementations of regular expressions, the parentheses not only limit the scope of alternatives divided by a "|", but also can be used to "remember" text matched by the subexpression enclosed
we refer to the matched text with \1, \2, etc..

" +([a-zA-Z]+) +\1 +" will match a space, followed by (at least one characters) followed by at least one space, followed by exactly the same match as before.
ex: "............. so so ......."

- * is greedy. it takes the longest possible string. you can use the ? to turn the greediness off.




packages to use

quanteda
readtext
spacyr

```{r}
install.packages("quanteda")
install.packages("readtext")
install.packages("spacyr")
install.packages("wordcloud")
```

# Loading in files using the readtext package
```{r}
require(readtext)

# Twitter json
dat_json <- readtext("~/Dropbox/QUANTESS/social media/zombies/tweets.json")
corp_twitter <- corpus(dat_json)
summary(corp_twitter, 5)
# generic json - needs a textfield specifier
dat_sotu <- readtext("~/Dropbox/QUANTESS/Manuscripts/collocations/Corpora/sotu/sotu.json",
                  textfield = "text")
summary(corpus(dat_sotu), 5)
# text file
dat_txtone <- readtext("~/Dropbox/QUANTESS/corpora/project_gutenberg/pg2701.txt", cache = FALSE)
summary(corpus(dat_txtone), 5)
# multiple text files
dat_txtmultiple1 <- readtext("~/Dropbox/QUANTESS/corpora/inaugural/*.txt", cache = FALSE)
summary(corpus(dat_txtmultiple1), 5)
# multiple text files with docvars from filenames
dat_txtmultiple2 <- readtext("~/Dropbox/QUANTESS/corpora/inaugural/*.txt",
                             docvarsfrom = "filenames", sep = "-",
                             docvarnames = c("Year", "President"))
summary(corpus(dat_txtmultiple2), 5)
# XML data
dat_xml <- readtext("~/Dropbox/QUANTESS/quanteda_working_files/xmlData/plant_catalog.xml",
                  textfield = "COMMON")
summary(corpus(dat_xml), 5)
# csv file
write.csv(data.frame(inaug_speech = texts(data_corpus_inaugural),
                     docvars(data_corpus_inaugural)),
          file = "/tmp/inaug_texts.csv", row.names = FALSE)
dat_csv <- readtext("/tmp/inaug_texts.csv", textfield = "inaug_speech")
summary(corpus(dat_csv), 5)
```




